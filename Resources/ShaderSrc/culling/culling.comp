#version 460

// defined work group size
layout (local_size_x = 128) in; // 128 elements at a time

layout (binding = 0) uniform CullUBO
{
    vec4  frustum[6];
    vec3  viewPos;
    float pad;
    uint  numObjects;
    uint  numDrawCalls;
} cullUbo;

struct ObjectRenderData
{
	mat4 model;
	mat4 inverseTransposeModel;
	vec2 mrif;
    int  baseIndex;
    uint meshId;
};

// all object matrices
layout(binding = 1, std430) buffer PerObjectBuffer
{
	ObjectRenderData objects[];
} perObjectBuffer;

struct CullingData
{
    vec3  albedo;
    float pad;
};

layout(binding = 2, std430) writeonly buffer CullingOutputData
{
    CullingData objects[];
} cullingOutputData;

// Same layout as VkDrawIndexedIndirectCommand
struct IndexedIndirectCommand 
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

layout(binding = 3, std430) buffer IndirectBuffer
{
    IndexedIndirectCommand drawcalls[];
} indirectBuffer;

struct InstanceData
{
    uint objectId;
};

layout(binding = 4, std430) buffer InstanceBuffer
{
    InstanceData objects[];
} instanceBuffer;

struct Sphere
{
    vec3 center;
    float radius;
};

Sphere BuildBoundingSphereFromModelMat(mat4 model)
{
    const vec3 xColumn = { model[0][0], model[1][0], model[2][0] };
    const vec3 yColumn = { model[0][1], model[1][1], model[2][1] };
    const vec3 zColumn = { model[0][2], model[1][2], model[2][2] };

    const vec3 globalScale = { length(xColumn), length(yColumn), length(zColumn) };
    const vec3 globalCenter = (model * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    const float maxScale = max(max(globalScale.x, globalScale.y), globalScale.z);

    Sphere bSphere;
    bSphere.center = globalCenter;
    bSphere.radius = maxScale;

    return bSphere;
}

bool IsInFrustum(Sphere sphere)
{
    for (int i = 0; i < 6; i++)
    {
        // outside the frustum
        if (dot(vec4(sphere.center, 1.0), cullUbo.frustum[i]) + sphere.radius < 0.0)
			return false;
    }
    return true;
}

vec3 ExtractPostionFromMat(mat4 model)
{
    vec3 pos;
    pos.x = model[0][3];
    pos.y = model[1][3];
    pos.z = model[2][3];
    return pos;
}

float ExtractScaleFromMat(mat4 model)
{
    vec3 col;
    col.x = model[0][0];
    col.y = model[0][1];
    col.z = model[0][2];
    return sqrt(dot(col, col));
}

#define TEST_NOT_CULL_ALBEDO vec3(1.0, 1.0, 1.0)
#define TEST_CULL_ALBEDO     vec3(1.0, 0.0, 0.0)

void main()
{
    // grab global ID
	uint gID = gl_GlobalInvocationID.x;

    if (gID == 0) // skip the first one, and clear the status
    {
        //for (int i = 0; i < cullUbo.numDrawCalls; ++i)
        //{
        //    indirectBuffer.drawcalls[i].instanceCount = 0;
        //}
        return;
    }

    // make sure we don't access past the buffer size
    if (gID <= cullUbo.numObjects)
    {
        // calculate the bounding sphere from model matrix
        mat4 model = perObjectBuffer.objects[gID].model;
        Sphere sphere = BuildBoundingSphereFromModelMat(model);

        if (IsInFrustum(sphere)) // in the frustum, camera can see it, don't cull
        {
            uint drawCallIndex = perObjectBuffer.objects[gID].meshId;

            //if (perObjectBuffer.objects[gID].mrif.z > 0.0) // have instance
            //{
            //    // data race??
            //    uint instanceId = indirectBuffer.drawcalls[drawCallIndex].instanceCount;
            //    instanceBuffer.objects[instanceId].position = ExtractPostionFromMat(model);
            //    instanceBuffer.objects[instanceId].scale = ExtractScaleFromMat(model);
            //    instanceBuffer.objects[instanceId].metallic = 0.63333333333333;
            //    atomicAdd(indirectBuffer.drawcalls[drawCallIndex].instanceCount, 1);
            //}
            cullingOutputData.objects[gID].albedo = TEST_NOT_CULL_ALBEDO;
        }
        else // camera can't see it, cull out.
        {
            cullingOutputData.objects[gID].albedo = TEST_CULL_ALBEDO;
        }
    }
}